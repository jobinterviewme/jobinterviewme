{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport RawAsyncValidator from 'async-validator';\nimport * as React from 'react';\nimport warning from \"rc-util/es/warning\";\nimport { setValues } from './valueUtil';\nimport { defaultValidateMessages } from './messages'; // Remove incorrect original ts define\n\nvar AsyncValidator = RawAsyncValidator;\n/**\n * Replace with template.\n *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo\n */\n\nfunction replaceMessage(template, kv) {\n  return template.replace(/\\$\\{\\w+\\}/g, function (str) {\n    var key = str.slice(2, -1);\n    return kv[key];\n  });\n}\n/**\n * We use `async-validator` to validate rules. So have to hot replace the message with validator.\n * { required: '${name} is required' } => { required: () => 'field is required' }\n */\n\n\nfunction convertMessages(messages, name, rule, messageVariables) {\n  var kv = _objectSpread(_objectSpread({}, rule), {}, {\n    name: name,\n    \"enum\": (rule[\"enum\"] || []).join(', ')\n  });\n\n  var replaceFunc = function replaceFunc(template, additionalKV) {\n    return function () {\n      return replaceMessage(template, _objectSpread(_objectSpread({}, kv), additionalKV));\n    };\n  };\n  /* eslint-disable no-param-reassign */\n\n\n  function fillTemplate(source) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Object.keys(source).forEach(function (ruleName) {\n      var value = source[ruleName];\n\n      if (typeof value === 'string') {\n        target[ruleName] = replaceFunc(value, messageVariables);\n      } else if (value && _typeof(value) === 'object') {\n        target[ruleName] = {};\n        fillTemplate(value, target[ruleName]);\n      } else {\n        target[ruleName] = value;\n      }\n    });\n    return target;\n  }\n  /* eslint-enable */\n\n\n  return fillTemplate(setValues({}, defaultValidateMessages, messages));\n}\n\nfunction validateRule(_x, _x2, _x3, _x4, _x5) {\n  return _validateRule.apply(this, arguments);\n}\n/**\n * We use `async-validator` to validate the value.\n * But only check one value in a time to avoid namePath validate issue.\n */\n\n\nfunction _validateRule() {\n  _validateRule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, value, rule, options, messageVariables) {\n    var cloneRule, subRuleField, validator, messages, result, subResults;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cloneRule = _objectSpread({}, rule); // We should special handle array validate\n\n            subRuleField = null;\n\n            if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {\n              subRuleField = cloneRule.defaultField;\n              delete cloneRule.defaultField;\n            }\n\n            validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));\n            messages = convertMessages(options.validateMessages, name, cloneRule, messageVariables);\n            validator.messages(messages);\n            result = [];\n            _context2.prev = 7;\n            _context2.next = 10;\n            return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread({}, options)));\n\n          case 10:\n            _context2.next = 15;\n            break;\n\n          case 12:\n            _context2.prev = 12;\n            _context2.t0 = _context2[\"catch\"](7);\n\n            if (_context2.t0.errors) {\n              result = _context2.t0.errors.map(function (_ref2, index) {\n                var message = _ref2.message;\n                return (// Wrap ReactNode with `key`\n\n                  /*#__PURE__*/\n                  React.isValidElement(message) ? /*#__PURE__*/React.cloneElement(message, {\n                    key: \"error_\".concat(index)\n                  }) : message\n                );\n              });\n            } else {\n              console.error(_context2.t0);\n              result = [messages[\"default\"]()];\n            }\n\n          case 15:\n            if (!(!result.length && subRuleField)) {\n              _context2.next = 20;\n              break;\n            }\n\n            _context2.next = 18;\n            return Promise.all(value.map(function (subValue, i) {\n              return validateRule(\"\".concat(name, \".\").concat(i), subValue, subRuleField, options, messageVariables);\n            }));\n\n          case 18:\n            subResults = _context2.sent;\n            return _context2.abrupt(\"return\", subResults.reduce(function (prev, errors) {\n              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));\n            }, []));\n\n          case 20:\n            return _context2.abrupt(\"return\", result);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[7, 12]]);\n  }));\n  return _validateRule.apply(this, arguments);\n}\n\nexport function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {\n  var name = namePath.join('.'); // Fill rule with context\n\n  var filledRules = rules.map(function (currentRule) {\n    var originValidatorFunc = currentRule.validator;\n\n    if (!originValidatorFunc) {\n      return currentRule;\n    }\n\n    return _objectSpread(_objectSpread({}, currentRule), {}, {\n      validator: function validator(rule, val, callback) {\n        var hasPromise = false; // Wrap callback only accept when promise not provided\n\n        var wrappedCallback = function wrappedCallback() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          } // Wait a tick to make sure return type is a promise\n\n\n          Promise.resolve().then(function () {\n            warning(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');\n\n            if (!hasPromise) {\n              callback.apply(void 0, args);\n            }\n          });\n        }; // Get promise\n\n\n        var promise = originValidatorFunc(rule, val, wrappedCallback);\n        hasPromise = promise && typeof promise.then === 'function' && typeof promise[\"catch\"] === 'function';\n        /**\n         * 1. Use promise as the first priority.\n         * 2. If promise not exist, use callback with warning instead\n         */\n\n        warning(hasPromise, '`callback` is deprecated. Please return a promise instead.');\n\n        if (hasPromise) {\n          promise.then(function () {\n            callback();\n          })[\"catch\"](function (err) {\n            callback(err || ' ');\n          });\n        }\n      }\n    });\n  });\n  var summaryPromise;\n\n  if (validateFirst === true) {\n    // >>>>> Validate by serialization\n    summaryPromise = new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n        var i, errors;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                i = 0;\n\n              case 1:\n                if (!(i < filledRules.length)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 4;\n                return validateRule(name, value, filledRules[i], options, messageVariables);\n\n              case 4:\n                errors = _context.sent;\n\n                if (!errors.length) {\n                  _context.next = 8;\n                  break;\n                }\n\n                reject(errors);\n                return _context.abrupt(\"return\");\n\n              case 8:\n                i += 1;\n                _context.next = 1;\n                break;\n\n              case 11:\n                /* eslint-enable */\n                resolve([]);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x6, _x7) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  } else {\n    // >>>>> Validate by parallel\n    var rulePromises = filledRules.map(function (rule) {\n      return validateRule(name, value, rule, options, messageVariables);\n    });\n    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function (errors) {\n      if (!errors.length) {\n        return [];\n      }\n\n      return Promise.reject(errors);\n    });\n  } // Internal catch error to avoid console error log.\n\n\n  summaryPromise[\"catch\"](function (e) {\n    return e;\n  });\n  return summaryPromise;\n}\n\nfunction finishOnAllFailed(_x8) {\n  return _finishOnAllFailed.apply(this, arguments);\n}\n\nfunction _finishOnAllFailed() {\n  _finishOnAllFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(rulePromises) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", Promise.all(rulePromises).then(function (errorsList) {\n              var _ref3;\n\n              var errors = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(errorsList));\n\n              return errors;\n            }));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _finishOnAllFailed.apply(this, arguments);\n}\n\nfunction finishOnFirstFailed(_x9) {\n  return _finishOnFirstFailed.apply(this, arguments);\n}\n\nfunction _finishOnFirstFailed() {\n  _finishOnFirstFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(rulePromises) {\n    var count;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            count = 0;\n            return _context4.abrupt(\"return\", new Promise(function (resolve) {\n              rulePromises.forEach(function (promise) {\n                promise.then(function (errors) {\n                  if (errors.length) {\n                    resolve(errors);\n                  }\n\n                  count += 1;\n\n                  if (count === rulePromises.length) {\n                    resolve([]);\n                  }\n                });\n              });\n            }));\n\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _finishOnFirstFailed.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/Users/ighil/Documents/ReactProyects/JobInterViewMe/node_modules/rc-field-form/es/utils/validateUtil.js"],"names":["_toConsumableArray","_defineProperty","_regeneratorRuntime","_asyncToGenerator","_typeof","_objectSpread","RawAsyncValidator","React","warning","setValues","defaultValidateMessages","AsyncValidator","replaceMessage","template","kv","replace","str","key","slice","convertMessages","messages","name","rule","messageVariables","join","replaceFunc","additionalKV","fillTemplate","source","target","arguments","length","undefined","Object","keys","forEach","ruleName","value","validateRule","_x","_x2","_x3","_x4","_x5","_validateRule","apply","mark","_callee2","options","cloneRule","subRuleField","validator","result","subResults","wrap","_callee2$","_context2","prev","next","type","defaultField","validateMessages","Promise","resolve","validate","t0","errors","map","_ref2","index","message","isValidElement","cloneElement","concat","console","error","all","subValue","i","sent","abrupt","reduce","stop","validateRules","namePath","rules","validateFirst","filledRules","currentRule","originValidatorFunc","val","callback","hasPromise","wrappedCallback","_len","args","Array","_key","then","promise","err","summaryPromise","_ref","_callee","reject","_callee$","_context","_x6","_x7","rulePromises","finishOnFirstFailed","finishOnAllFailed","e","_x8","_finishOnAllFailed","_callee3","_callee3$","_context3","errorsList","_ref3","_x9","_finishOnFirstFailed","_callee4","count","_callee4$","_context4"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport RawAsyncValidator from 'async-validator';\nimport * as React from 'react';\nimport warning from \"rc-util/es/warning\";\nimport { setValues } from './valueUtil';\nimport { defaultValidateMessages } from './messages'; // Remove incorrect original ts define\n\nvar AsyncValidator = RawAsyncValidator;\n/**\n * Replace with template.\n *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo\n */\n\nfunction replaceMessage(template, kv) {\n  return template.replace(/\\$\\{\\w+\\}/g, function (str) {\n    var key = str.slice(2, -1);\n    return kv[key];\n  });\n}\n/**\n * We use `async-validator` to validate rules. So have to hot replace the message with validator.\n * { required: '${name} is required' } => { required: () => 'field is required' }\n */\n\n\nfunction convertMessages(messages, name, rule, messageVariables) {\n  var kv = _objectSpread(_objectSpread({}, rule), {}, {\n    name: name,\n    enum: (rule.enum || []).join(', ')\n  });\n\n  var replaceFunc = function replaceFunc(template, additionalKV) {\n    return function () {\n      return replaceMessage(template, _objectSpread(_objectSpread({}, kv), additionalKV));\n    };\n  };\n  /* eslint-disable no-param-reassign */\n\n\n  function fillTemplate(source) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Object.keys(source).forEach(function (ruleName) {\n      var value = source[ruleName];\n\n      if (typeof value === 'string') {\n        target[ruleName] = replaceFunc(value, messageVariables);\n      } else if (value && _typeof(value) === 'object') {\n        target[ruleName] = {};\n        fillTemplate(value, target[ruleName]);\n      } else {\n        target[ruleName] = value;\n      }\n    });\n    return target;\n  }\n  /* eslint-enable */\n\n\n  return fillTemplate(setValues({}, defaultValidateMessages, messages));\n}\n\nfunction validateRule(_x, _x2, _x3, _x4, _x5) {\n  return _validateRule.apply(this, arguments);\n}\n/**\n * We use `async-validator` to validate the value.\n * But only check one value in a time to avoid namePath validate issue.\n */\n\n\nfunction _validateRule() {\n  _validateRule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, value, rule, options, messageVariables) {\n    var cloneRule, subRuleField, validator, messages, result, subResults;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cloneRule = _objectSpread({}, rule); // We should special handle array validate\n\n            subRuleField = null;\n\n            if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {\n              subRuleField = cloneRule.defaultField;\n              delete cloneRule.defaultField;\n            }\n\n            validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));\n            messages = convertMessages(options.validateMessages, name, cloneRule, messageVariables);\n            validator.messages(messages);\n            result = [];\n            _context2.prev = 7;\n            _context2.next = 10;\n            return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread({}, options)));\n\n          case 10:\n            _context2.next = 15;\n            break;\n\n          case 12:\n            _context2.prev = 12;\n            _context2.t0 = _context2[\"catch\"](7);\n\n            if (_context2.t0.errors) {\n              result = _context2.t0.errors.map(function (_ref2, index) {\n                var message = _ref2.message;\n                return (// Wrap ReactNode with `key`\n\n                  /*#__PURE__*/\n                  React.isValidElement(message) ? /*#__PURE__*/React.cloneElement(message, {\n                    key: \"error_\".concat(index)\n                  }) : message\n                );\n              });\n            } else {\n              console.error(_context2.t0);\n              result = [messages.default()];\n            }\n\n          case 15:\n            if (!(!result.length && subRuleField)) {\n              _context2.next = 20;\n              break;\n            }\n\n            _context2.next = 18;\n            return Promise.all(value.map(function (subValue, i) {\n              return validateRule(\"\".concat(name, \".\").concat(i), subValue, subRuleField, options, messageVariables);\n            }));\n\n          case 18:\n            subResults = _context2.sent;\n            return _context2.abrupt(\"return\", subResults.reduce(function (prev, errors) {\n              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));\n            }, []));\n\n          case 20:\n            return _context2.abrupt(\"return\", result);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[7, 12]]);\n  }));\n  return _validateRule.apply(this, arguments);\n}\n\nexport function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {\n  var name = namePath.join('.'); // Fill rule with context\n\n  var filledRules = rules.map(function (currentRule) {\n    var originValidatorFunc = currentRule.validator;\n\n    if (!originValidatorFunc) {\n      return currentRule;\n    }\n\n    return _objectSpread(_objectSpread({}, currentRule), {}, {\n      validator: function validator(rule, val, callback) {\n        var hasPromise = false; // Wrap callback only accept when promise not provided\n\n        var wrappedCallback = function wrappedCallback() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          // Wait a tick to make sure return type is a promise\n          Promise.resolve().then(function () {\n            warning(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');\n\n            if (!hasPromise) {\n              callback.apply(void 0, args);\n            }\n          });\n        }; // Get promise\n\n\n        var promise = originValidatorFunc(rule, val, wrappedCallback);\n        hasPromise = promise && typeof promise.then === 'function' && typeof promise.catch === 'function';\n        /**\n         * 1. Use promise as the first priority.\n         * 2. If promise not exist, use callback with warning instead\n         */\n\n        warning(hasPromise, '`callback` is deprecated. Please return a promise instead.');\n\n        if (hasPromise) {\n          promise.then(function () {\n            callback();\n          }).catch(function (err) {\n            callback(err || ' ');\n          });\n        }\n      }\n    });\n  });\n  var summaryPromise;\n\n  if (validateFirst === true) {\n    // >>>>> Validate by serialization\n    summaryPromise = new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n        var i, errors;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                i = 0;\n\n              case 1:\n                if (!(i < filledRules.length)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 4;\n                return validateRule(name, value, filledRules[i], options, messageVariables);\n\n              case 4:\n                errors = _context.sent;\n\n                if (!errors.length) {\n                  _context.next = 8;\n                  break;\n                }\n\n                reject(errors);\n                return _context.abrupt(\"return\");\n\n              case 8:\n                i += 1;\n                _context.next = 1;\n                break;\n\n              case 11:\n                /* eslint-enable */\n                resolve([]);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x6, _x7) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  } else {\n    // >>>>> Validate by parallel\n    var rulePromises = filledRules.map(function (rule) {\n      return validateRule(name, value, rule, options, messageVariables);\n    });\n    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function (errors) {\n      if (!errors.length) {\n        return [];\n      }\n\n      return Promise.reject(errors);\n    });\n  } // Internal catch error to avoid console error log.\n\n\n  summaryPromise.catch(function (e) {\n    return e;\n  });\n  return summaryPromise;\n}\n\nfunction finishOnAllFailed(_x8) {\n  return _finishOnAllFailed.apply(this, arguments);\n}\n\nfunction _finishOnAllFailed() {\n  _finishOnAllFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(rulePromises) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", Promise.all(rulePromises).then(function (errorsList) {\n              var _ref3;\n\n              var errors = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(errorsList));\n\n              return errors;\n            }));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _finishOnAllFailed.apply(this, arguments);\n}\n\nfunction finishOnFirstFailed(_x9) {\n  return _finishOnFirstFailed.apply(this, arguments);\n}\n\nfunction _finishOnFirstFailed() {\n  _finishOnFirstFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(rulePromises) {\n    var count;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            count = 0;\n            return _context4.abrupt(\"return\", new Promise(function (resolve) {\n              rulePromises.forEach(function (promise) {\n                promise.then(function (errors) {\n                  if (errors.length) {\n                    resolve(errors);\n                  }\n\n                  count += 1;\n\n                  if (count === rulePromises.length) {\n                    resolve([]);\n                  }\n                });\n              });\n            }));\n\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _finishOnFirstFailed.apply(this, arguments);\n}"]},"metadata":{},"sourceType":"module"}